{"pages":[{"title":"","text":"估算你的 5E 天梯分数估算你的 5E 天梯分数请输入要查询的玩家 5e 主页链接 范例：https://www.5ewin.com/data/player/ec2d3z 估算查询结果usernameelovar fiveEProfilePrefix = 'https://www.5ewin.com/data/player/'; var apiEndPoint = 'https://5e-elo-estimator.azurewebsites.net/api/infer-elo?code=uBqXdMi6ney0iD3zLBepnfSsalnFH1/JXFTz7SFSAOfu8Ab9Vom3wg=='; var profileUrlTextBox = $('#5e-profile-url'); var button = $('#estimate-button'); var buttonText = $('#estimate-button-text'); var spinner = $('#estimate-loading'); var resultPanel = $('.result'); var userIdText = $('#user-id'); var userEloText = $('#user-elo'); var userAvatarImg = $('#user-avatar'); function startEstimatingStatus() { profileUrlTextBox.attr('disabled', true); button.attr('disabled', true); buttonText.text('估算中...'); spinner.removeAttr('hidden'); resultPanel.attr('hidden', true); } function endEstimatingStatus() { profileUrlTextBox.removeAttr('disabled'); button.removeAttr('disabled'); buttonText.text('估算'); spinner.attr('hidden', true); } $('#estimate-button').on('click', function () { startEstimatingStatus(); var profileUrl = $('#5e-profile-url').val(); if (!profileUrl.startsWith(fiveEProfilePrefix)) { alert('请输入有效的 5E 主页链接!'); endEstimatingStatus(); return; } axios.get(apiEndPoint + `&id=${profileUrl}`) .then((function (resp) { if (resp.status != 200) { alert('服务器返回状态码：' + resp.status); return; } var data = resp.data; if (data.success) { resultPanel.removeAttr('hidden'); userAvatarImg.attr('src', data.data.avatar); userIdText.text(data.data.username); if (data.data.elo != 0) { userEloText.text(data.data.elo); } else { userEloText.text(`${data.data.lower_limit}~${data.data.upper_limit}`); } } else { alert('查询失败，原因：' + data.message); } })) .finally(function () { endEstimatingStatus(); }); });","link":"/5e-elo.html"},{"title":"柯原玉 / Tony Ke","text":"TO BE ADDED SOON","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"","text":"估算你的 5E 天梯分数估算你的 5E 天梯分数请输入要查询的玩家 5e 主页链接 范例：https://www.5ewin.com/data/player/ec2d3z 估算查询结果usernameelovar fiveEProfilePrefix = 'https://www.5ewin.com/data/player/'; var apiEndPoint = 'https://5e-elo-estimator.azurewebsites.net/api/infer-elo?code=uBqXdMi6ney0iD3zLBepnfSsalnFH1/JXFTz7SFSAOfu8Ab9Vom3wg=='; var profileUrlTextBox = $('#5e-profile-url'); var button = $('#estimate-button'); var buttonText = $('#estimate-button-text'); var spinner = $('#estimate-loading'); var resultPanel = $('.result'); var userIdText = $('#user-id'); var userEloText = $('#user-elo'); var userAvatarImg = $('#user-avatar'); function startEstimatingStatus() { profileUrlTextBox.attr('disabled', true); button.attr('disabled', true); buttonText.text('估算中...'); spinner.removeAttr('hidden'); resultPanel.attr('hidden', true); } function endEstimatingStatus() { profileUrlTextBox.removeAttr('disabled'); button.removeAttr('disabled'); buttonText.text('估算'); spinner.attr('hidden', true); } $('#estimate-button').on('click', function () { startEstimatingStatus(); var profileUrl = $('#5e-profile-url').val(); if (!profileUrl.startsWith(fiveEProfilePrefix)) { alert('请输入有效的 5E 主页链接!'); endEstimatingStatus(); return; } axios.get(apiEndPoint + `&id=${profileUrl}`) .then((function (resp) { if (resp.status != 200) { alert('服务器返回状态码：' + resp.status); return; } var data = resp.data; if (data.success) { resultPanel.removeAttr('hidden'); userAvatarImg.attr('src', data.data.avatar); userIdText.text(data.data.username); if (data.data.elo != 0) { userEloText.text(data.data.elo); } else { userEloText.text(`${data.data.lower_limit}~${data.data.upper_limit}`); } } else { alert('查询失败，原因：' + data.message); } })) .finally(function () { endEstimatingStatus(); }); });","link":"/5e-elo/index.html"}],"posts":[{"title":"持之以恒训练打卡记录","text":"失败了，坚持了3个月，败给懒惰每天坚持做 100 个俯卧撑每天坚持一项室内体育运动，暂定持续一年。没有特殊的健身目的，只是为了寻找一件事情让自己每天都努力去完成，锻炼自律性。最开始的版本是一天 100 个俯卧撑，后来咨询一下发现俯卧撑是要隔天做的，因为会对肌肉产生劳损，所以打算找多几种运动来挑战，不局限于俯卧撑从 Jan.16, 2019 开始到 Jan.16, 2020 结束，然后开始新的挑战AprilApr.10-18 暂停一下，这阵子身体实在不太行Apr.3-9 又生病了，休息一下Apr.2 俯卧撑 75 个Apr.1 俯卧撑 75 个MarchMar.31 俯卧撑 75 个Mar.30 俯卧撑 75 个Mar.29 俯卧撑 75 个Mar.28 俯卧撑 75 个Mar.27 俯卧撑 75 个Mar.26 俯卧撑 75 个Mar.25 俯卧撑 75 个Mar.24 俯卧撑 75 个Mar.23 俯卧撑 75 个Mar.22 俯卧撑 75 个Mar.21 俯卧撑 75 个Mar.20 俯卧撑 75 个Mar.19 俯卧撑 75 个Mar.13-18 生病了，休息一下Mar.12 俯卧撑 75 个Mar.11 俯卧撑 100 个Mar.10 深蹲 75 个Mar.9 剪蹲 75 个Mar.8 俯卧撑 75 个Mar.7 俯卧撑 75 个Mar.6 俯卧撑 75 个Mar.5 俯卧撑 75 个Mar.4 俯卧撑 75 个Mar.3 俯卧撑 75 个Mar.2 俯卧撑 75 个Mar.1 俯卧撑 75 个FebruaryFeb.28 俯卧撑 75 个Feb.27 俯卧撑 75 个Feb.26 俯卧撑 75 个Feb.25 俯卧撑 75 个Feb.24 俯卧撑 75 个Feb.23 俯卧撑 75 个Feb.22 俯卧撑 75 个Feb.21 俯卧撑 75 个Feb.20 俯卧撑 75 个Feb.19 剪蹲 100 个Feb.18 俯卧撑 75 个Feb.17 深蹲 100 个Feb.16 仰卧起坐 100 个Feb.15 剪蹲 100 个Feb.14 俯卧撑 75 个Feb.13 深蹲 100 个Feb.12 俯卧撑 65 个Feb.11 俯卧撑 75 个Feb.10 俯卧撑 75 个Feb.9 俯卧撑 75 个Feb.8 深蹲 100 个Feb.7 俯卧撑 75 个Feb.6 俯卧撑 75 个Feb.5 俯卧撑 75 个Feb.5 俯卧撑 75 个Feb.4 深蹲 100 个Feb.3 剪蹲 80 个Feb.2 俯卧撑 75 个Feb.1 深蹲 60 个JanuaryJan.31 俯卧撑 50 个Jan.30 俯卧撑 50 个Jan.29 俯卧撑 50 个Jan.28 剪蹲 100 个Jan.27 俯卧撑 50 个 + 剪蹲 100 个，肩膀酸Jan.26 仰卧起坐 100 个Jan.25 俯卧撑 60 个Jan.24 俯卧撑 60 个Jan.23 俯卧撑 40 个Jan.22 剪蹲 80 个Jan.21 深蹲 75 个Jan.20 俯卧撑 40 个Jan.19 仰卧起坐 80 个Jan.18 剪蹲 100 个Jan.17 深蹲 80 个Jan.16 俯卧撑 100 个","link":"/2019/01/16/365-days-challenge/"},{"title":"由 Eval 引申到 Redis Cluster 的学习","text":"背景因为业务需要写了一段 Redis 的 Lua Script，在调用 EVAL 的时候发现还有两个参数 KEYS 和 ARGV，感觉很疑惑，难道不是简单的传点参数进去就可以？所以了解了一下这两个参数的含义。EVAL 命令的定义是1EVAL script numkeys key [key ...] arg [arg ...]All Redis commands must be analyzed before execution to determine which keys the command will operate on. In order for this to be true for EVAL, keys must be passed explicitly. This is useful in many ways, but especially to make sure Redis Cluster can forward your request to the appropriate cluster node.Redis 设计的原意是使用者应当将在 Lua Script 中操作的所有 KEY 以 KEYS 的形式传给 EVAL，这样 EVAL 能够在真正运行前检查一下 KEY，就目前来说，是根据 KEYS 来决定把指令转发到哪台 Redis Cluster Master Node 上。ARGV 则是传递一些必要的参数，这个倒是没什么使用规范。于是我先放下 EVAL，了解一下 Redis Cluster，用了这么久 Redis 了，还没用过 Redis Cluster，惭愧。Redis ClusterRedis Cluster 简单的来说就是若干 Redis 节点组成集群，数据根据 KEY 被分散到不同的节点上面，而不是节点之间互为 Replication。KEY 的分散策略不是 Consistent Hashing，而是一种叫做 Slots 的机制，在文章最后我再介绍一下我对 Slots 机制的理解。也正是因为 Slots 机制，指令到达 Redis Cluster 的节点之后会根据 KEY 选择合适的 Slot，然后客户端重新连接到对应的节点再执行操作，而不是某个节点转发指令到对应 KEY 的节点。一个 Redis Cluster 一共有 16384 个 Slots，最开始创建集群的时候这 16384 个 Slots 会被平均分散到各个节点上面，也可以通过命令来手动调整，至于为什么是 16384 个 Slots，感兴趣的同学可以看一下作者在这个 Issue 上的回答Availability前面说到 Redis 节点之间数据互相独立，所以只要有节点挂了，这个节点负责的 Slots 的数据也变得无法访问从而整个集群的节点都会拒绝访问，处于 CLUSTERDOWN 的状态。因此 Redis Cluster 也利用了 Master-Slave 机制用于提供 Availability，即 Master 节点会异步复制自己的数据（其实是复制操作）到它 N 个的 Slave 节点，也就是说一个 Slot 对应的 Key 们会有 N+1 份数据分布在 Master 和 Slave 上。当某个 Master 挂了的时候，集群会把它的 Slave 升级到 Master，这样子集群就能继续工作。当然，如果一对 Master-Slave 都挂了那集群也就挂了。通常来说，所有操作都会在 Master 上进行，Slave 只是充当备胎的作用，只有 Master 挂了 Slave 才能上位。不过 Slave 也不是一无是处，客户端可以通过执行 READONLY 命令来将客户端切换到只读模式，这样子读操作就会在 Slave 上进行。ConsistencyRedis Cluster 并不能保证很好的数据一致性，在某些极端情况下还是有可能丢数据的：第一种丢失数据的情况Master 没有成功复制消息到 Slave。在 Master-Slave 模式下，对 Master 的操作是同步的，即操作成功后才会返回给客户端相应的消息，但是 Master -&gt; Slave 的复制是异步的，假设一种情况：客户端 SET a 1Master 接收到指令 SET a 1，回复给客户端 OKMaster 在发送给 Slave SET a 1 之前崩了Slave 上位成 Master这时候 a=1 这个数据就丢失了。这种情况也不是不能避免，Redis Cluster 提供了 WAIT 指令来做到这件事情。客户端发送 WAIT 指令之后，Redis Cluster 会 Block 住直到客户端的上一条操作有 N 个 Slave 都回复 ACK 了。第二种丢失数据的情况网络隔离。假设我们有一个三节点集群，每个 Master 节点有一个 Slave，节点命名为 A-A1, B-B1, C-C1，以及一个客户端 D发生网络隔离的情况下，D 和少数 Master（C） 形成一个孤岛，其他大多数 Master 形成一个孤岛。孤岛 AD、C孤岛 BA、A1、B、B1、C1t0C 与集群失联，开始等待恢复连接等待时间为 node timeout[4]集群与 B 失联，开始等待 B 恢复连接等待时间为 node timeoutt1D 向 C 节点写数据持续等待t2C 等待超时切换状态到 error，拒绝写入新数据集群等待超时通过选举将 C1 提升为新的 Mastert3与集群恢复联系与 D C 恢复联系恢复联系后，因为原来的 Master C 已经被多数成员认为不可用淘汰掉了，C1 被选为新的 Master，C 加回集群后被降级为 Slave。因为先前 D 向 C 写的数据没有同步到 C1，所以数据丢失。回到 EVAL在一个节点接收到 EVAL 指令之后，他会检查 KEYS，算出对应的 Slots，如果所有 KEY 不是落到同一个 Slot 上，会提示 CROSSSLOT Keys in request don't hash to the same slot那如果我不传 KEYS，直接在脚本中操作呢？还是会报错。12$ redis-cli EVAL &quot;redis.call(&apos;get&apos;, &apos;slot a&apos;); redis.call(&apos;get&apos;, &apos;slot-b&apos;)&quot; 0ERR Error running script (call to f_8ead0f68893988e15c455c0b6c8ab9982e2e707c): @user_script:1: @user_script: 1: Lua script attempted to access a non local key in a cluster node所以 EVAL 的时候，脚本中操作的 Key 应当保证落在同一个 Slot 里面。同时 Redis 也提供了一个方法可以保证 Key 都会落到同一个 Slot 上面，下面讲 Slots 机制的时候会讲到以上关于 EVAL 的操作都是建立在对 Redis Cluster 操作的基础上的，如果使用的是单一节点，则可以不考虑这些问题，可以胡来。Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.Slots 机制SLOT = CRC16(key) mod 16384Redis 集群的拓扑结构是是一个全连通的网络，每一个节点之间都会建立一个 Cluster Bus，所以集群的任何配置变动都会立即同步到各个节点，也就是说，每一个节点都知道哪些 Slot 对应哪个节点。所以不论客户端连接到哪个节点进行执行指令，服务端都会正确的指示客户端应当重定向到哪一个节点来操作。Key 在做 CRC16 的时候，如果 Key 中存在花括号对，Redis 会使用花括号对里面字符串做 CRC16，例如12{user:info:}1234 =&gt; crc16(&quot;user:info:&quot;) % 16384{user:info:}5737 =&gt; crc16(&quot;user:info:&quot;) % 16384虽然是两个不同的 Key，但是花括号中间部分是一样的，所以他们有相同的 Slot。参考资料[1] https://github.com/antirez/redis/issues/2576[2] https://redis.io/topics/cluster-spec[3] https://redis.io/commands/eval[4] https://redis.io/topics/cluster-tutorial","link":"/2019/04/17/a-glance-at-redis-cluster/"},{"title":"在 macOS 上构建、打包 Medis","text":"Medis 是一款简洁易用、实用的 Redis 图形化客户端，作者将这款软件在 Github 上开源，所有开发者可以自由下载它的源代码。Medis 在 App Store 上提供了下载，价值 ¥30，算是一种形式上的捐赠吧，不愿意花钱的开发者也可以根据本文的指示来构建并打包 Medis，与从 App Store下载的版本并无区别。前提Xcode &gt;= 8.2.1macOS &gt;= 10.11.6Node 8（我只在装了 Node 8 的机器上尝试过）自力更生123456789101112131415161718192021# 1. 下载最新源代码$ git clone https://github.com/luin/medis.gitCloning into 'medis'...remote: Counting objects: 3154, done.remote: Total 3154 (delta 0), reused 0 (delta 0), pack-reused 3154Receiving objects: 100% (3154/3154), 48.44 MiB | 1.89 MiB/s, done.Resolving deltas: 100% (1745/1745), done.$ cd medis# 2. 安装依赖$ npm install...added 1295 packages from 1824 contributors in 49.707s# 3. 打包，忽略 Unhandled rejection Error$ npm run packPackaging app for platform mas x64 using electron v1.4.15flating... ~/Desktop/medis/out/Medis-mas-x64/Medis.appUnhandled rejection Error: No identity found for signing. at ~/Desktop/medis/node_modules/electron-osx-sign/flat.js:114:35 ...(stack error info)至此，Medis 已经打包完毕，Medis.app 存放在 Medis 源代码目录下的 out/Medis-mas-x64 目录里面，运行 Medis.app 即可启动 Medis安装也可以在 Finder 中将 Medis.app 放入应用程序目录来安装，也可以用运行如下命令来安装：12# 此时处于 Medis 源代码根目录下$ mv out/Medis-mas-x64/Medis.app ~/ApplicationsLet’s enjoy Medis!Thank you luin!","link":"/2018/07/18/build-medis-on-macos/"},{"title":"Kubernetes 学习札记 - 在 Google Cloud 上搭建集群","text":"Target搭建 Kubernetes 集群（Master * 1 + Node * 2）MachinesHostnameMachine Typekube-mastern1-standardkube-node-1n1-standardkube-node-2n1-standardPreparation on Master Machine安装 Docker 和 Kubeadm保存下面脚本为 init-k8s-master.sh123456789101112131415161718192021#!/bin/sh# install dockerapt-get updateapt-get install -y apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"apt-get updateapt-get install -y docker-ce# install k8scurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -echo \"deb http://apt.kubernetes.io/ kubernetes-xenial main\" &gt;&gt; /etc/apt/sources.list.d/kubernetes.listapt-get updateapt-get install -y kubelet kubeadm kubectl# ONLY run on master# configure cgroupsed -i \"s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g\" /etc/systemd/system/kubelet.service.d/10-kubeadm.confsystemctl daemon-reloadsystemctl restart kubelet执行上述脚本 sudo source init-k8s-master.sh选择一个 Pod 网络组件（Pod Network Add-on）组件有很多种，这里我选择了 Flannel，具体操作见接下来两个步骤启动集群 Master12# 这里的 --pod-network-cidr=10.244.0.0/16 取决于你选择的网络组件sudo kubeadm init --pod-network-cidr=10.244.0.0/16启动了之后从结果的最后几行里面获得一串命令行，用于操作 Node 加入集群，记下来，这个命令行有用123# 获得一串类似于这样子的命令# 10.0.0.3 是我的 Master IPkubeadm join 10.0.0.3:6443 --token 8qn683.9ft7dc6xa0re697a --discovery-token-ca-cert-hash sha256:65773046272db8297b64cbc1ce8ebc3884fa932976673fad7715c2bd8c53c6a0设置环境变量，方便调用 kubectl如果想让非 root 用户使用 kubectl ，执行123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config对于 root 用户，直接设置环境变量1export KUBECONFIG=/etc/kubernetes/admin.conf这样设置之后， kubectl 才能正常运行安装网络组件检查节点123$ kubectl get nodesNAME STATUS ROLES AGE VERSIONkube-master NotReady master 1m v1.11.0会发现 STATUS 为 NotReady ，运行 kubectl describe nodes 得到最后一行日志是 Container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not ready: cni config uninitialized ，说明网络组件还没有配置好，需要设置一下。这里我选择了 Flannel 作为网络组件，执行1kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml再次检查节点123$ kubectl get nodesNAME STATUS ROLES AGE VERSIONkube-master Ready master 2m v1.11.0至此 Master 配置完毕，准备配置 NodePreparation for Node Machines安装 Docker 和 Kubeadm参照 Master 安装教程，删去 cgroup 配置部分加入集群12# 在 Master 进行 kubeadm init 的时候获得的提示kubeadm join 10.0.0.3:6443 --token 8qn683.9ft7dc6xa0re697a --discovery-token-ca-cert-hash sha256:65773046272db8297b64cbc1ce8ebc3884fa932976673fad7715c2bd8c53c6a0检查节点状态在 Master 上执行 kubectl get nodes12345$ kubectl get nodesNAME STATUS ROLES AGE VERSIONkube-master Ready master 2m v1.11.0kube-node-1 Ready master 3m v1.11.0kube-node-2 Ready master 3m v1.11.0所有 STATUS 均为 Ready，完美资料参考：Creating a single master cluster with kubeadm","link":"/2018/07/06/learn-k8s-1/"},{"title":"使用 GitHub Actions 完成自动化部署 Hexo 博客","text":"GitHub 于 2018 年 8 月向公众宣告了他们的 CI 系统 GitHub Actions，这是一套自动化的工作流系统，可以对一个项目的开发起到很好的辅助作用。直到我写这篇文章的时候，GitHub Actions 还处于 Beta 阶段。我已经拿到了测试资格，出于尝鲜的目的，便把我的博客的自动化部署从 Travis 转移到 Actions 上。写此文章分享我对 GitHub Actions 的了解。由于我之前只用过 Travis 和 Jenkins，而 Jenkins 的使用作为一个非运维人员来说是不太需要关心的，所以下文介绍 Actions 的过程中，我更多地会通过对比 Travis 来进行介绍。简单介绍 GitHub Actions市面上比较流行的同类产品有：Travis，是一个第三方在线 CI/CD 服务提供商，一开始向 GitHub 的仓库提供免费服务，后来遍逐渐地成为了多数 GitHub 用户的首选AppVeyor，与 Travis 不同的是，AppVeyor 提供了比较好的 Windows 环境支持，这吸引了一部分 Windows 软件开发者Jenkins，这是一套开源的 CI/CD 系统，很多商业公司会选择在内部服务器自己搭建一套完整的 CI/CD 系统，并与他们的私有库以及线上机器集群结合起来，从而优化工作流。我的前东家们（字节跳动、即刻）使用的都是这样子的结构一些概念Workflow一个 Workflow 即是一个可配置的自动化工作流，这个工作流由单个或者多个 Job 组成。工作流的启动可以通过事件（比如 git push）来触发，也可以通过定时任务来触发。Workflow 的配置通过一个 yaml 文档来体现，这个文档存放在 &lt;repo&gt;/.github/workflows/&lt;workflow_name&gt;.yml，具体规范可见 Workflow syntax for GitHub Actions，本文不会提及所有语法内容，只会覆盖需要用到的语句。Job由一系列具体 Step 组成的一个任务。每一个 Job 会运行在一个独立的虚拟环境里面。Job 之间可以是并行的，也可以是有依赖关系的，这个可以在 Workflow 中进行配置。举个🌰，一个项目可以由四个 Job 组成：两个编译基础组件的 Job（并行）一个编译主程序的 Job（依赖上面两个 Job）一个运行测试用例的 Job（当且仅当主程序 Job 编译成功的时候运行）StepStep 定义了每一个步骤所做的事情，可以是运行某行命令，或者是使用某一个 Action。Step 的运行与否是可以通过条件来控制的，但本文不会 Cover 这个内容。Action一个 Workflow 可以抽象成为一个比较通用的功能，从而分享给别人使用。Action 就是这样的存在。在 GitHub Actions 里面，是不会像 Travis 那样默认从当前 Repo 去 Clone 源码的，你需要定义一个 Step 来 Checkout。当然，每次写 Workflow 都要写上 git clone blablabla 无疑是对人力的一种不必要损耗，于是就有了一个叫做 checkout 的 Action。使用 Action 部署 Hexo先贴上我的 Workflow 定义 deploy.yml，然后我们逐行解析这份 Workflow 定义1234567891011121314151617181920212223242526272829303132name: Compile and Deploy to GitHub Pageon: push: branches: - sourcejobs: build: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 with: submodules: true ref: refs/heads/source - uses: actions/setup-node@v1 with: node_version: '8.x' - name: Setup Git user info run: | git config --global user.email \"thagki9@outlook.com\" git config --global user.name \"GitHub Actions\" - name: Install dependencies run: npm ci - name: Compile and deploy blog run: ./deploy.sh env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}Workflow 的名称12# line 1name: Compile and Deploy to GitHub Page定义这个 Workflow 的名称为「Compile and Deploy to GitHub Page」触发条件12345# line 3-6on: push: branches: - source定义了在事件 push 发生，并且目标分支为 source 的时候触发这个 WorkflowJobs12345678910# line 8-10jobs: build: runs-on: ubuntu-18.04 steps: - ... - ... - ... - ... - ...在这个简单的项目里面，我只有一个叫做 build 的 Job，基础运行环境是 ubuntu-18.04，目前可以选择的基础环境有 ubuntu, windows 和 macOS。这个 Job 包含了 5 个小任务步骤 1、2、3：设置基础环境1234567891011121314# line 12-24 - uses: actions/checkout@v1 with: submodules: true ref: refs/heads/source - uses: actions/setup-node@v1 with: node_version: '8.x' - name: Setup Git user info run: | git config --global user.email \"thagki9@outlook.com\" git config --global user.name \"GitHub Actions\"第一个步骤使用了 actions/checkout 的预定义 Action，携带了参数 submodules 和 ref，表示将会从默认目录（跟环境变量有关）Clone 分支 source，并且 Clone 相应的 submodule。第二个步骤使用了 actions/setup-node ，携带参数 node_version，表示将会设置好 node 8.x 的环境。第三个步骤我给他定义了个名字叫做「Setup Git user info」，运行了两行命令，用于设置 git 命令行的默认邮箱和名称。关于参数的使用，涉及到一个叫做 Context 的概念，不过在上面概念介绍的时候我没有提及，有兴趣的读者可以阅读 Contexts and expression syntax for GitHub Actions。步骤 4：安装项目依赖123# line 26-27 - name: Install dependencies run: npm ci这个步骤只执行了一行命令，那就是 npm ci，用于安装项目的第三方依赖，包括 Hexo 等等。步骤 5：执行部署脚本12345# line 29-32 - name: Compile and deploy blog run: ./deploy.sh env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}这里比较有意思的是执行脚本的时候附带了一个 GITHUB_TOKEN 的环境变量，这个变量的内容是 $ ，这是一种 Actions Workflow 提供的语法，用于使用一些灵活的表达式，比如这个表达式的意思就是从 secrets 这个 Context 拿 GITHUB_TOKEN 这个值。secrets.GITHUB_TOKEN 其实是 GitHub Actions 预定义的一个值，这个值就是一个 OAuth Access Token，可以用来对 GitHub 库进行读写操作。显然我们不愿意在 Workflow 里面写上自己的 GitHub 账户和密码，所以这里我们会用到 Access Token 来 Push 最终的博客静态文件到 GitHub Page 库。并且由于 GitHub Actions 有对敏感数据的保护，所以 secrets 下的所有变量是不会泄露到日志里面的。deploy.sh 的内容我就不解析了，大概就是 Clone 了原有的 GitHub Pages 仓库，删掉里面的所有东西，然后重新生成，以产生正确的 Diff 记录，最后 Commit &amp; Push。GitHub Actions 的机会那么，作为一款新入市场的产品，Actions 凭什么能和其他成熟产品竞争呢？在我看来有几个关键点与 GitHub 的无缝融合是天生优势，在 Actions 能用的情况下，谁又会去使用第三方的 CI/CD 呢Workflow 的可复用性在 GitHub 这个开源社区显得更为耀眼，减少了很多重复工作，其实上面这些部署步骤，我相信我去搜索一下「GitHub Actions Workflow Deploy Hexo」，直接 uses 一下应该也是 OK 的微软的慷慨：每个 Repo 可以同时运行 20 个 Workflow；每个 Job 可以运行长达 6 个小时；高性能的运行环境。这无疑是对开源社区的一种馈赠，开源软件的 CI/CD 可以更高效地推进功能的强大：在仔细阅读了文档之后我发现 Actions 提供的功能是非常强大的，轻量 Workflow 配置也赋予了 Actions 更多的可能。如果在正式商用之后能够给出比较合适的价格，我相信有些小型企业是会乐意使用 GitHub + GitHub Actions 的模式来进行开发的","link":"/2019/09/20/hexo-cicd-on-github-actions/"},{"title":"SSL Handshake 被莫名其妙地 RST","text":"最近我接的外包项目甲方又要开一个新的项目，于是丢过来几台阿里云的服务器，我来负责服务器基础架构的搭建，其实也就是网关，Runtime，Redis, Syslog 那些东西，已经做得滚瓜烂熟了。这次打算自己编译 OpenResty，调教出一个高性能网关，于是弄好了 OpenResty，也顺手把甲方发过来的 SSL 证书配置到了 OpenResty 上。配置 HTTPS 的过程跟以前一样，设置好 ssl_certificate, ssl_certificate_key,listen 443 ssl http2 这些东西，再附加一些 ssl_cipher 方面的参数，openresty -s reload 完事。reload 完了之后我在我本地的 Chrome 上通过域名访问了 https://xxx.com (xxx.com) 为甲方域名，一开始几次访问是 ERROR_CONNECTION_RESET，我也不以为然，因为服务器上的 OpenResty 刚 Reload，以及我本机上常着的 Surge 代理有时候可能会断线，所以我以为这种情况比较常见，刷新几次就好了，见到了 Welcome To OpenResty。晚上回家之后团队的小伙伴告诉我他访问不了这个服务器的 https，我自己试了一下确实没法访问，一直提示 ERROR_CONNECTION_RESET，偶尔成功。这时候我才开始重视起来，准备研究一下这个问题。症状在本机上 curl 只有极小的概率会返回正确结果，大部分时候返回12$ curl https://xxx.comcurl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to xxx.com:443在阿里云同一 VPC 内其他机器 curl 则必成功无论在哪里直接 curl -k https://&lt;ip&gt; 都是可以正常访问的排查问题过程之前用的 SSL 证书都是使用 certbot 来自助签发 Let's Encrypt 的三个月证书，这次使用的是在阿里云买的 Encryption Everywhere DV TLS CA - G1 签发的证书，我猜测甲方发给我的证书格式有问题，但是很快否定了这个猜测，因为前面讲到刷新多几次还是能访问的，并且 Chrome 能够给出正确的证书信息。之前没有用过自己编译的 OpenResty，于是我换了个预编译版的 nginx，也就是直接通过 yum install nginx 来安装的 nginx，问题依旧。开了 wireshark 来抓包可以发现这么一个过程：TCP Handshake -&gt; SSL Client Hello -&gt; Reset(Server sent)我有幸地抓到了部分没有被 Reset 的请求，可以看出，成功的请求的 Client Hello与被 Reset 的 Client Hello 的大小都是 583 Byte，并且我详细的对比了两个 Packet，发现除了时间戳以及必要的随机数之外并没有不一样的地方。我查看一下了 OpenResty 的错误日志，发现有大量的 peer closed connection in SSL handshake：1234562019/05/09 22:23:48 [info] 5182#0: *5543 peer closed connection in SSL handshake (104: Connection reset by peer) while SSL handshaking, client: &lt;ip&gt;, server: 0.0.0.0:4432019/05/09 22:23:49 [info] 5183#0: *5544 peer closed connection in SSL handshake (104: Connection reset by peer) while SSL handshaking, client: &lt;ip&gt;, server: 0.0.0.0:4432019/05/09 22:23:49 [info] 5183#0: *5545 peer closed connection in SSL handshake (104: Connection reset by peer) while SSL handshaking, client: &lt;ip&gt;, server: 0.0.0.0:4432019/05/09 22:23:50 [info] 5183#0: *5546 peer closed connection in SSL handshake (104: Connection reset by peer) while SSL handshaking, client: &lt;ip&gt;, server: 0.0.0.0:4432019/05/09 22:23:50 [info] 5182#0: *5547 peer closed connection in SSL handshake (104: Connection reset by peer) while SSL handshaking, client: &lt;ip&gt;, server: 0.0.0.0:4432019/05/09 22:23:50 [info] 5183#0: *5548 peer closed connection in SSL handshake (104: Connection reset by peer) while SSL handshaking, client: &lt;ip&gt;, server: 0.0.0.0:443也就是说，OpenResty 认为客户端在握手过程中主动关闭了连接，但是我的抓包结果却是服务端主动 RST 了连接，这让我感到很疑惑，为何两端能得出不一样的结论。由于不是很理解 SSL 握手的机制，我猜测 OpenSSL 接管了这一过程，所以我重新编译了 OpenResty，加上了最新版的 OpenSSL，问题依旧。至此我没辙了，只能 Google, StackOverflow 一遍一遍地搜，搜到了用直接 OpenSSL 来建立 SSL 连接的方法，于是我12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$ openssl s_client -connect xxx.com:443CONNECTED(00000005)depth=2 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert Global Root CAverify return:1depth=1 C = US, O = DigiCert Inc, OU = www.digicert.com, CN = Encryption Everywhere DV TLS CA - G1verify return:1depth=0 CN = &lt;Hidden Part&gt;verify return:1---Certificate chain 0 s:/CN=e.duchenggo.com i:/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=Encryption Everywhere DV TLS CA - G1 1 s:/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=Encryption Everywhere DV TLS CA - G1 i:/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=DigiCert Global Root CA---Server certificate&lt;Hidden Part&gt;subject=/CN=&lt;Hidden Part&gt;issuer=/C=US/O=DigiCert Inc/OU=www.digicert.com/CN=Encryption Everywhere DV TLS CA - G1---No client certificate CA names sentServer Temp Key: ECDH, X25519, 253 bits---SSL handshake has read 3246 bytes and written 285 bytes---New, TLSv1/SSLv3, Cipher is ECDHE-RSA-CHACHA20-POLY1305Server public key is 2048 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1.2 Cipher : ECDHE-RSA-CHACHA20-POLY1305 Session-ID: E5BC4CB0FFCA949F99859E6F2B6AE6D8742C6F6723EF7388ED7AED4F81C01126 Session-ID-ctx: Master-Key: 86D3EB1512786A84CE6E0ACF43362174345399F7C32A89B725893D2791AF87EBD1F642600CCA9919D57CDCB6FF6B203B TLS session ticket lifetime hint: 300 (seconds) TLS session ticket: 0000 - 85 3a da c6 e3 ab 66 f9-7b f8 e7 cd f6 a5 da e9 .:....f.{....... 0010 - ba bc d9 15 74 cf 8d b0-56 ea 4d c9 b4 f3 b7 d1 ....t...V.M..... 0020 - 1f 47 c1 1e ac 56 13 16-ca 6c d0 b8 bd 28 15 ea .G...V...l...(.. 0030 - 59 b3 79 84 b0 40 34 a4-57 e9 d1 12 c2 b5 5e 0f Y.y..@4.W.....^. 0040 - 77 02 ff 8b 4c 23 2b 89-b6 25 61 15 af 77 7c 75 w...L#+..%a..w|u 0050 - 6c 1f 80 66 27 0b 90 c4-36 43 e0 ee 75 f9 2d 99 l..f'...6C..u.-. 0060 - a0 af d3 bf 6d 12 05 f9-13 21 46 fd 41 a8 56 da ....m....!F.A.V. 0070 - df ec 89 68 d1 71 9d 15-2e 2f fa de 89 6a a0 8e ...h.q.../...j.. 0080 - 82 45 85 ca 3b 26 a0 e8-64 a9 56 82 da cf 04 4d .E..;&amp;..d.V....M 0090 - 42 13 dc 25 17 aa 38 1e-36 0a 8f 66 b5 26 57 2c B..%..8.6..f.&amp;W, 00a0 - 70 5e ff 0b 41 eb 49 f1-b0 8b 86 fd e6 c1 36 28 p^..A.I.......6( Start Time: 1557413139 Timeout : 7200 (sec) Verify return code: 0 (ok)---成功建立了 SSL 连接，显示的证书也是正确的，并且每一次执行都能稳定建立连接，而不是看运气才能连接得上，我抓包了这个建立过程，发现这种 Client Hello 是不携带 SNI Extension 的，如果我手动给他附上 SNI 呢？12345678910111213141516171819202122232425$ openssl s_client xxx.com:443 -servername xxx.comCONNECTED(00000005)write:errno=54---no peer certificate available---No client certificate CA names sent---SSL handshake has read 0 bytes and written 0 bytes---New, (NONE), Cipher is (NONE)Secure Renegotiation IS NOT supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session: Protocol : TLSv1.2 Cipher : 0000 Session-ID: Session-ID-ctx: Master-Key: Start Time: 1557413484 Timeout : 7200 (sec) Verify return code: 0 (ok)---果不其然，无法完成握手！锁定元凶经过一系列排查之后，终于发现携带了 SNI 的 SSL 握手请求大概率会被 “神秘力量” Reset。联想到这个域名还没有来得及备案，我猜想大概就是因为没有备案所以被干扰。但是以前的未备案只是 HTTP 会被劫持流量，难道阿里云已经增强了技术开始干扰未备案域名的 HTTPS 连接了吗？搜索了一番发现很早之前就有人讨论过这个问题了v2ex - 阿里云竟然也能 RESET 掉 HTTPS 链接了..?v2ex - 阿里云香港和新加坡 HTTPS 极其不稳定至此结束调查，请甲方去对域名进行备案。真是一个无聊的调查结果，不过也是记录一下，希望其他人遇到这个问题的时候能够搜到我的文章别再浪费时间到这个问题上","link":"/2019/05/09/wired-ssl-handshake-reset/"}],"tags":[{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"DIY","slug":"DIY","link":"/tags/DIY/"},{"name":"Medis","slug":"Medis","link":"/tags/Medis/"},{"name":"kubernetes","slug":"kubernetes","link":"/tags/kubernetes/"},{"name":"学习札记","slug":"学习札记","link":"/tags/学习札记/"},{"name":"GitHub Actions","slug":"GitHub-Actions","link":"/tags/GitHub-Actions/"},{"name":"建站之路","slug":"建站之路","link":"/tags/建站之路/"},{"name":"CI","slug":"CI","link":"/tags/CI/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"踩坑","slug":"踩坑","link":"/tags/踩坑/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"}],"categories":[{"name":"LifeRecorder","slug":"LifeRecorder","link":"/categories/LifeRecorder/"},{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"ShareAnything","slug":"ShareAnything","link":"/categories/ShareAnything/"},{"name":"Debugging","slug":"Debugging","link":"/categories/Debugging/"}]}